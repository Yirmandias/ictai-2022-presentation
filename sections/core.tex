\section{Acting for multi-agents}
\subsection{Deliberative acting}
\begin{frame}{Definition of a robotic agent}

    \begin{columns}[T]
        \begin{column}{0.3\textwidth}
            An entity

            ~

            \includegraphics[width = 0.7\textwidth]{images/icons8-robot-gustav-500.png}
        \end{column}
        \begin{column}{0.7\textwidth}
            \center Capable of :
            \pause
            \begin{enumerate}
                \item Perceiving its environment
                \pause
                \item Modifying its environment (actions)
                \pause
                \item \textbf{Deliberating:} Reasoning about its \textbf{skills} in order to fulfill a goal
            \end{enumerate}
        \end{column}
    \end{columns}

 
\end{frame}

\begin{frame}{Representing the skills of an agent}

\begin{columns}[T]
    \begin{column}{0.55\textwidth}

        \begin{itemize}
            \item Elementary capabilities : move, grasp, look, \dots
            \pause
            \item Skills : executable programs (operational models): set the table, \dots
            \pause
            \item Robot behavior = composition of skills
        \end{itemize}
        
        ~
        \pause
        Acting domain \textbf{$A_\Delta (A, T, M_t)$}: Hierarchical operational models
        \small
        \pause
        \begin{itemize}
        
        
         \item[$A$] : primitive tasks
         \pause
         \item[$T$] : abstract tasks
         \pause
         \item[$M_t$] : methods: pre-conditions, body (operational model)
         
     \end{itemize}
    \end{column}
    \pause
    \begin{column}{0.45\textwidth}
        \begin{figure}
            \begin{tikzpicture}
                \node[draw,ellipse, ultra thick] (t) {\textit{open door}} [sibling distance = 3.5cm]
                  child {node[draw, ultra thick] (m1) {$m_1$} edge from parent [dashed]
                  child {node[draw,rounded corners, ultra thick, solid] (a1) {$push$} edge from parent
                  }} 
                  child {node[draw, ultra thick] (m2) {$m_2$} edge from parent [dashed] [sibling distance = 1.5cm]
                  child {node[draw, rounded corners, solid, ultra thick] (a2) {grab handle} edge from parent [solid]}
                  child {node[draw, rounded corners, solid, ultra thick] {$pull$} edge from parent [solid]}};
                \node[right = 0em of t] {$\in T$};
                \node[right = 0em of m1] {$\in M_t$};
                \node[right = 0em of m2] {$\in M_t$};
                \node[right = 0em of a1] {$\in A$};

            \end{tikzpicture}
            \caption{Example of hierarchy for the \textit{task} \textit{open door}}

            
        \end{figure}
    \end{column}
\end{columns}
    
\end{frame}

\begin{frame}{Refinement Acting Engine (RAE)\footnote{Automated Planning and Acting \cite{ghallabAutomatedPlanningActing2016}}: deliberation algorithms using hierarchical operational models}
    RAE features:
    \begin{itemize}
        \item Hierarchical representation of the agent skills.
        \item Refinement at runtime:
        \centering
        \begin{tikzpicture}
            \node[] (task) {$\tau(p_1,\dots,p_n)$};
            \node[below = 2em of task] (method) {$m(p_1,\dots,p_n, \dots, p_m)$};
            \path[->] (task) edge node[right, midway] {refinement} (method);
        \end{tikzpicture}
        \item Monitoring command and task execution.
        \item Perform multiple tasks in parallel
        \pause
        \item Automated deliberation: Refinement of task into method and choice of parameters
    \end{itemize}    
\end{frame}
    

\begin{frame}{Refinement Acting Engine algorithms}
    \begin{columns}[T]
  
        \begin{column}{0.65\textwidth}
            
            Algorithms:
            \small
            \begin{itemize}
                \setlength{\leftmargini}{-1pt}
                \onslide<2->
                \item \textbf{Main:} 
                \begin{itemize}
                    \item Receive $\tau$ (task or event);
                    
                    add it to the \textbf{agenda} (ongoing tasks)
                    \onslide<3->
                    \item Refine $\tau$: \textbf{Select} an applicable method $m$ for $\tau$
                    \onslide<4->
                    \item \textbf{Progress} $m$
                \end{itemize}
                \onslide<5->
                \item \textbf{Progress:}
                    \begin{itemize}
                        \onslide<6->
                        \item Monitor execution of $m$.
                        \onslide<7->
                        \item Refine subtasks in $m$.    
                        \onslide<8->
                        \item Monitor execution of subtasks.
                        \onslide<9->
                        \item \textbf{Retry} $\tau$ in case of \emph{failure}:
                    
                    Call \textbf{Select} to get a new method;
                    
                    \textbf{Progress} the new method.
                    \end{itemize}
            \end{itemize}
        \end{column}
        \begin{column}{0.35\textwidth}
            \begin{tikzpicture}
                \onslide<2>
                \node[draw,ellipse, ultra thick] (t) {$\tau$};
                \onslide<3-9>
                \node[draw,ellipse, ultra thick, color = orange] (t) {$\tau$};
                \onslide<10>
                \node[draw,ellipse, ultra thick, color = green] (t) {$\tau$};
                \onslide<3>
                \node[draw, ultra thick, below= 2em of t, xshift = -3em] (m1) {$m_1$};
                \node[draw, ultra thick, below= 2em of t, xshift = 3em] (m2) {$m_2$};
                \onslide<4->
                \node[draw, ultra thick, below= 2em of t, xshift = -3em, color = orange] (m1) {$m_1$};
                \node[draw, ultra thick, below= 2em of t, xshift = 3em, color = gray] (m2) {$m_2$};
                \onslide<10>
                \node[draw, ultra thick, below= 2em of t, xshift = -3em, color = green] (m1) {$m_1$};
                \onslide<3->
                \path[-] (t) edge (m1) (t) edge (m2);
                \onslide<5>
                \node[draw,rounded corners, ultra thick, solid, below = 2em of m1, xshift = -1.5em] (a1) {$a1$};
                \onslide<6>
                \node[draw,rounded corners, ultra thick, solid, below = 2em of m1, xshift = -1.5em, color = orange] (a1) {$a1$};
                \onslide<7->
                \node[draw,rounded corners, ultra thick, solid, below = 2em of m1, xshift = -1.5em, color = green] (a1) {$a1$};
                \onslide<5-7>
                \node[draw,ellipse, ultra thick, solid, below = 2em of m1, xshift = 1.5em] (t2) {$\tau_s$};
                \onslide<8->
                \node[draw,ellipse, ultra thick, solid, below = 2em of m1, xshift = 1.5em, color = orange] (t2) {$\tau_s$};
                \onslide<10>
                \node[draw,ellipse, ultra thick, solid, below = 2em of m1, xshift = 1.5em, color = green] (t2) {$\tau_s$};
  
  
                \onslide<5->
                \path[-] (m1) edge (a1) (m1) edge(t2);
  
  
                \onslide<7>
                \node[draw, ultra thick, below = 2em of t2, xshift = -1.5em] (m3) {$m_3$};
                \node[draw, ultra thick, below = 2em of t2, xshift = 1.5em] (m4) {$m_4$};
                \path[-] (t2) edge  (m3) (t2) edge (m4);
                
                \onslide<8>
                \node[draw, ultra thick, below = 2em of t2, xshift = -1.5em, color = orange] (m3) {$m_3$};
                \node[draw, ultra thick, below = 2em of t2, xshift = 1.5em, color = gray] (m4) {$m_4$};
                \path[-] (t2) edge  (m3) (t2) edge (m4);
  
                \onslide<9->
                \node[draw, ultra thick, below = 2em of t2, xshift = -1.5em, color = red] (m3) {$m_3$};
                \node[draw, ultra thick, below = 2em of t2, xshift = 1.5em, color = orange] (m4) {$m_4$};
                \path[-] (t2) edge  (m3) (t2) edge (m4);
                \onslide<10>
                \node[draw, ultra thick, below = 2em of t2, xshift = 1.5em, color = green] (m4) {$m_4$};
                
                \onslide<8->
                \node[below = 2em of m3, xshift = -1em] (e3) {};
                \node[below = 2em of m3, xshift = 1em] (e4) {};
                \path[-] (m3) edge  (e3) (m3) edge (e4);
  
                \onslide<8->
                \node[below = 2em of m4, xshift = -1em] (e5) {};
                \node[below = 2em of m4, xshift = 1em] (e6) {};
                \path[-] (m4) edge  (e5) (m4) edge (e6);
      
            \end{tikzpicture}
        \end{column}
    \end{columns}    
\end{frame}
\subsection{OMPAS: Extending RAE for fleet management}

\begin{frame}{Multi-agent: extending RAE definition for concurrency}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            RAE shortcomings:
            \begin{itemize}
                \item Progression of tasks relies on Round Robin
                \item Methods limited to a sequence of actions
                \item Difficulties to integrate sound planning from operational models due to implementation in Python.
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            RAE extension:
            \begin{itemize}
                \item Progression handled by a scheduler
                \item Complex method bodies:
                \begin{itemize}
                    \item Concurrency inside methods
                    \item General programming constructs
                    \item error and interruption handling
                \end{itemize}
                \item Reasoning on shared resources for the interleaving of tasks.
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{Adaptation of the main algorithm}
    \begin{itemize}
        \item Each task is evaluated in its own thread.
        \item Shared objects among all threads: state, resources
    \end{itemize}
  
    \tikzstyle{thread} = [draw, rounded corners, rectangle, fill=black!50]
    \begin{tikzpicture}[scale=0.97, every node/.style={scale=0.97}]
  
        %RAE
        \node[draw = black, very thick,
            minimum width = 14em,
            minimum height = 5em,
            rounded corners,
            text = black,
            text centered, text depth = 4 cm,
            align = center,
            ] (R) at (0,0) {\textbf{OMPAS}};
        %Operational Models
        % \node[draw = black, ellipse, very thick,
        %     minimum width = 7em,
        %     minimum height = 2em,
        %     above = 1em of R,
        %     text = black,
        %     text centered, align=center
        % ] (OM) {\textit{Operational Models} %($A_\Delta$)
        % };
  
  
        %state
        \node[draw = black, very thick,
        text centered,
        minimum width = 13em,
        minimum height = 2em,
        rounded corners,
        text = black,
        fill=black!10,
        align = center] (S) at ($(R.south) + (0,0.6)$) {State};
  
        %main
        \node[draw = black, very thick,
        minimum height = 8em,
        minimum width = 13em,
        rounded corners,
        text = black,
        text centered, text depth = 7em,
        fill=black!10,
        align=center] (main) at ($(R.north) + (0,-2)$) {Main};
  
        %t1
        \node[draw = black, thick,
        minimum height = 6em,
        minimum width = 7em,
        rounded corners,
        text = black,
        text centered, text depth = 5em,
        fill=black!20,
        align=center](t1) at ($(main.south) + (-0.8, 1.3)$) {\emph{transport($o_1$,$l_7$)}};
  
  
        %first task
        \node[draw, rounded corners, rectangle, fill=black!30] (st11) at ($(t1.south) + (0,1.3)$) {\emph{drive($t_1$,$l_8$)}};
        \node[draw, rounded corners, rectangle, fill=black!30] (st12) at ($(st11.south) + (0,-.5)$){\emph{pack($o_1$)}};
        
        \node[draw, thick, rounded corners, rectangle,minimum width = 4em, fill=black!20, align= center] (t3) at ($(t1.east) + (0.9, 0.3)$){\textit{monitor}\\
        \textit{-fuel}($t_1$)};
        \node[draw, thick, rounded corners, rectangle,minimum width = 4em, fill=black!20, align= center] (t3) at ($(t1.east) + (0.9, -0.5)$){\dots};
  
  
  
        %platform
        \node[draw = black, very thick,
        text centered,
        minimum width = 5em,
        minimum height = 2em,
        %below = 2em of R,
        rounded corners,
        text = black,
        align = center,] (Pl) at ($(R.west) +(-8em, -2em)$) {Platform};
  
        \node[text centered,
        minimum width = 5em,
        minimum height = 2em,
        below = 1.5em of Pl,
        rounded corners,
        text = black,
        align = center,] (E) {\textbf{\large\textit{Environment}}};
  
        \node[very thick,
            text centered,
            rounded corners,
            text = black] (U) at ($(R.west) +(-8em, +4em)$) {\Large \textbf{User}};
        
        % \node[draw = black, very thick,
        %     text centered,
        %     right = 7em of R,
        %     minimum width = 5em,
        %     minimum height = 4em,
        %     rounded corners,
        %     text = black] (Pl) {Platform};
        
  
        \path[->]
  
            %Link between operational models library
            %(OM) edge (R)
  
            (U.20) edge[bend left] node [midway, above, align=center] {\footnotesize \emph{Tasks}} (main.+140)
            (R.+160) edge [bend left] node [midway, above] {\footnotesize \emph{Reports}} (U.-20)
        
            %Link between RAE and the platform
            (main.-160) edge[bend left] node [pos = 0.6, above = 0.2em] {\footnotesize \emph{Commands}} (Pl.east)
            
            %between platform and state
            (Pl.-20) edge [bend right] node [pos = 0.7, right, above, align = center] {\footnotesize \emph{Updates}} (S.west)
            
            %between platform and main
            (Pl.20) edge [bend left] node [pos = 0.3, right, above= 0.2em, align = center] {\footnotesize \emph{Events}} (main.-170)
  
            (Pl.-110) edge (E.110)
            (E.70) edge (Pl.-70)
            ;
        
        \end{tikzpicture}

\end{frame}

\subsection{An acting language based on Scheme}
\begin{frame}{SOMPAS: A Lisp variant with acting primitives}
    
    \begin{columns}
        \begin{column}{0.5\textwidth}
            Why Scheme?
            \begin{itemize}
                \item Few primitives
                \item Functional
                \item Generic programming constructs
                \item Identified and simple semantic $\rightarrow$ suitable to automated analysis for planning
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            Features :
            \begin{itemize}
                \item Concurrency and interruption
                \item Acting primitives
                \item Resource acquisition mechanism for synchronization and exclusion.
            \end{itemize}

        \end{column}
    \end{columns}
\end{frame}

\begin{frame}[fragile]{Concurrency and interruption}
    handle: new LValue
    Functions:
    \begin{itemize}
        \item \textit{(async e)}: creates a new thread to evaluate e, returns a handle
        \item \textit{(await h)}: awaits the result of the concurrent evaluation.
        \item \textit{(interrupt h)}: interrupts the concurrent evaluation.
    \end{itemize}
    
\begin{columns}
    \begin{column}{0.4\textwidth}
        \lstset{basicstyle=\footnotesize, columns=fullflexible}
\begin{lstlisting}[language=lisp]
(begin
 (define h
  (async 
    (begin
     (uninterruptible (begin
       (exec pick ?r ?o)
       (exec move ?r ?l)
       (exec drop ?r ?o)))
     (exec inspect ?r ?o))))
 (race 
   (await h)
   (begin
    (sleep 10)
    (interrupt h))))
\end{lstlisting}

    \end{column}
    \begin{column}{0.6\textwidth}
        \newcommand{\Cross}{$\mathbin{\tikz [x=1.4em,y=1.4em,line width=.2em, red] \draw (0,0) -- (1,1) (0,1) -- (1,0);}$}
    \begin{tikzpicture}
        \node[draw,
        rounded corners,
        ultra thick,
        minimum height = 3em,
            minimum width = 7em,] (pick) at (0,0) {pick r1 o3};
    
        \node[draw, rounded corners,
        ultra thick,
            minimum height = 3em,
            minimum width = 7em,
        ] (move) at ($1.5*(pick.south)-0.5*(pick.north)$) {move r1 l6};
        %\action{move, move r1 l6, 10em, pick}
    
        \node[draw, rounded corners,
        ultra thick,
            minimum height = 3em,
            minimum width = 7em,
        ] (drop) at ($1.5*(move.south) - 0.5*(move.north)$) {drop r1 o3};
        \node[draw, rounded corners,
        ultra thick,
            minimum height = 3em,
            minimum width = 7em,
        ] (inspect) at ($1.5*(drop.south) - 0.5*(drop.north)$) {inspect r1 o3};
        \node at (inspect) {\Cross};
    
            \node[] (origin) at ($(pick.north west) + (-1em,+0.5em)$) {~~};
        
            \node[] (zero) at ($(origin.west) + (-1em,0)$) {0};
            \draw[-, ultra thick] (origin.west) -- (origin.east);
            \node[] (ten) at ($(zero) + (0,-6em)$) {10};
            \draw[-, ultra thick] ($(origin.west) + (0,-6em)$) -- ($(origin.east) + (0,-6em)$);
    
    
            \node[] (interruption) at ($(ten.east) +(11em,0em)$){\color{red} \textit{Int.}};%{\color{red} \textit{interruption}};
            \draw[-, ultra thick, dashed, color= red] ($(ten.east)$) -- ( interruption);
            \node[] (end) at ($1.5*(inspect.south west) - 0.5*(inspect.south west) + (-1em,-1em)$) {};
            \node[] (time) at ($1.5*(end.south east) - 0.5*(end.south east) + (2em,0)$)  {time (seconds)};
    
    
        \path[->] (origin.center) edge[ultra thick] (end);
    \end{tikzpicture}
    \end{column}
\end{columns}    
\end{frame}

\begin{frame}{Acting primitives}
    \begin{itemize}
    \pause
        \item \textit{(exec a $p_1...p_n$)} executes and monitors a task or command.
    \pause
        \begin{itemize}
            \item command : resorts to the platform
            \item task: selects a method and execute its operational model.
        \end{itemize}
    \pause
        \item \textit{(read-state sf $p_1...p_n$)} returns the value of a state-variable
        \item \textit{(arbitrary set $\lambda$)} returns an arbitrary element from a $set$. $\lambda$ can be used to select among the $set$.
    \end{itemize}
\end{frame}

\begin{frame}[t]{Resources}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            Definition of a resource:
            \begin{itemize}
                \item Object with initial capacity $C_{init}$
                \item Acquire $r$ at $t$ with amount $c$: $c \leq C_t$ 
            \end{itemize}
            Kinds of resources : 
            \begin{itemize}
                \item \emph{unary}: $C_{init} = 1$, $c = 1$;
                \item \emph{divisible}: $C_{init} \in  \mathbb{R}_+^*$, $c \in ]0, C_t]$
            \end{itemize}
        \end{column}
        \begin{column}{0.5\textwidth}
            Functions
            \begin{itemize}
                \item \textit{(new-resource r C)}: declare a new resource with a label and a capacity.
                \item \emph{(acquire r c)} request the acquisition of $r$ with amount $c$. Returns a resource-handle
                \item \emph{(release h)} release the resource of the resource-handle
            \end{itemize}
        \end{column}
    \end{columns}
\end{frame}

\begin{frame}{More advanced features and programming constructs}
    More complex behavior definition
    \begin{itemize}
        \item \textit{(wait-for dyn)} waits until the expression \textit{dyn} becomes true 
        \item \textit{(run-monitoring e dyn)} evaluates \textit{e} while \textit{dyn} is true, interrupts \textit{e} otherwise.
        \item ...
    \end{itemize}
\end{frame}

\begin{frame}[t,fragile]{Defining an acting domain with SOMPAS}
    \setlength{\leftmargini}{0pt}
    \begin{columns}
        \begin{column}{0.5\textwidth}
            \begin{itemize}
                \footnotesize
                \item Task (label, typed parameters):
                \tiny
                \begin{lstlisting}
(def-task t_process_package
    (:params (?p package)))
                \end{lstlisting}
                \footnotesize
                \pause
                \item Method (label, typed parameters, pre-conditions, body):
                \tiny
                \begin{lstlisting}
(def-method m_process_to_do_r
  (:task t_process_package)
  (:params (?p package))
  (:pre-conditions
    (!= (package.processes_list ?p)
        nil)))
  (:body
    (do
     (define ?m ...)
     (t_process_on_machine ?p ?m)
     (t_process_package ?p)))   
                \end{lstlisting}
            \end{itemize}
        \end{column}
    \pause
        \begin{column}{0.5\textwidth}
            \begin{itemize}
    \pause
            \footnotesize
            \item State-function (label, typed parameters \& result):
            \tiny
            \begin{lstlisting}
(def-state-function at
    (:params (?r robot))
    (:result location))
            \end{lstlisting}
    \pause
            \footnotesize
            \item Command (label, typed parameters):
            \tiny
            \begin{lstlisting}
(def-command pick (:params (?r robot)))
                \end{lstlisting}
            \end{itemize}

    \pause
            ~
        \normalsize
        Others:
        
        \textit{lambda, type, constant}
        \end{column}

    \end{columns}
\end{frame}